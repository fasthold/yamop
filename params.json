{"name":"Yamop","tagline":"Yet another MongoDB ODM for PHP","body":"- [What's that?](#whatsthat)\r\n- [Requirements](#requirements)\r\n- [Installation](#installation)\r\n- [Usage](#usage)\r\n    - [getting](#getting)\r\n    - [save, update, delete](#save)\r\n    - [embedded objects](#embedded)\r\n    - [relations](#related)\r\n    - [output format](#output)\r\n    - [pagination](#pagination)\r\n    - [timestamps](#timestamps)\r\n    - [dates and time](#datetime)\r\n    - [transactions](#transactions)\r\n- [Issues](#Issues)\r\n- [License](#license)\r\n\r\n<a name=\"whatsthat\"></a>\r\n## What's that? \r\nThis is yet another, open source, and very simple ODM for [MongoDB](http://www.mongodb.org/).\r\nIt works like the standard MongoDB PHP extension interface but returns objects instead of arrays (as ODM). Queries stay the same.\r\nOne of its coolest features are joins which allow you to query for related objects.\r\n\r\nList of features:\r\n\r\n- [String IDs](#stringid) (easier linking in views)\r\n- [Embedded objects](#embedded)\r\n- [Related objects](#related) (performing \"join like\" operations)\r\n- [JSON format](#output)\r\n- [Paginator](#pagination)\r\n- [Timestamps](#timestamps) (created_at and updated_at fields added on demand)\r\n- [Printing date and time](#datetime)\r\n- [Transactions](#transactions) (PHP error support only)\r\n\r\n<a name=\"requirements\"></a>\r\n## Requirements\r\n+ PHP 5.3+\r\n+ PHP MongoDB Extension\r\n\r\n<a name=\"installation\"></a>\r\n## Installation \r\n\r\nYou can simply download it [here](https://github.com/mawelous/yamop) or use [Composer](http://getcomposer.org/).\r\n\r\nIn the `require` key inside the `composer.json` file add the following\r\n\r\n```yml\r\n    \"mawelous/yamop\": \"dev-master\"\r\n```\r\n\r\nSave it and run the Composer update command\r\n\r\n    $ composer update\r\n\r\nAfter Composer is done you only need to add the following lines to your code\r\n\r\n```php\r\n    $connection = new \\MongoClient( 'your_host' );\r\n    \\Mawelous\\Yamop\\Mapper::setDatabase( $connection->db_name );\r\n```\r\n\r\nYou can pass any `MongoDB` instance to the `setDatabase` function.\r\n\r\nNow extend `Mawelous\\Yamop\\Model` from within any of your models:\r\n\r\n```php\r\n    class User extends \\Mawelous\\Yamop\\Model\r\n    {\r\n        protected static $_collectionName = 'users';    \r\n    }\r\n```\r\n\r\nThat's it!\r\n\r\n<a name=\"usage\"></a>\r\n##Usage\r\n\r\nEach object has an `_id`, which is a `MongoId`, and an `id` key which is its string representation.\r\n\r\nEvery document in `MongoDB` is returned as an object, every key is a property - here a sample document inside `MongoDB`\r\n\r\n```json\r\n     {\r\n       \"_id\": ObjectId(\"51b6ea4fb7846c9410000001\"),\r\n       \"name\": \"John Doe\",\r\n       \"birthdate\": ISODate(\"2013-05-25T12:15:25.0Z\"),\r\n       \"email\": \"john@something.com\"\r\n    }    \r\n```\r\nThe document above would be represented in PHP as follows:\r\n\r\n```php\r\n    object(User)[44]\r\n      public '_id' => \r\n        object(MongoId)[46]\r\n          public '$id' => string '51b6ea4fb7846c9410000001' (length=24)\r\n      public 'name' => string 'John Doe' (length=8)\r\n      public 'birthdate' => \r\n        object(MongoDate)[47]\r\n          public 'sec' => int 1369484125\r\n          public 'usec' => int 0\r\n      public 'email' => string 'john@something.com' (length=18)\r\n      public 'id' => string '51b6ea4fb7846c9410000001' (length=24)\r\n```\r\n\r\n<a name=\"getting\"></a>\r\n### Getting data\r\nWant to get a document by its id? There is a simple way.\r\n\r\n<a name=\"stringid\"></a>\r\n```php\r\n    $stringId = ;\r\n    $user = User::findById( '51a61930b7846c400f000002' )\r\n    //or\r\n    $mongoId = new MongoId( '51a61930b7846c400f000002' );\r\n    $user = User::findById( $mongoId )\r\n```\r\n#### Introducing Mapper\r\nThere is a `Mapper` class in Yamop which is responsible for retrieving data. I separated it from `Model` so it can stay as data container. If you want to create more complicated queries you want to use the mapper. You can get it by using the `getMapper` method or creating new instance of it passing model class as string.\r\n\r\n```php\r\n    //first possibility\r\n    $mapper = User::getMapper();\r\n    //second possibility\r\n    $mapper = new Mawelous\\Yamop\\Mapper( 'User' );\r\n```\r\n\r\n#### Find methods\r\n\r\n`findOne` works exactly like native [`findOne`](#http://php.net/manual/en/mongocollection.findone.php) but it returns an object. As second parameter you can pass an array of fields. This means the parameters and queries stay the same, which is pretty great!\r\n\r\n`find` also works like native [`find`](#http://www.php.net/manual/en/mongocollection.find.php) but it returns a `Mapper`. You can then perform other operations on it like `sort`, `limit`, `skip` which all work like native as well.\r\nTo get result as array of objects use `get` method.\r\n\r\n```php\r\n    $messages = Message::getMapper()\r\n        ->find( array( 'to_id' => new MongoId( $stringId ), 'to_status' => Message::STATUS_UNREAD ) )\r\n        ->sort( array( 'created_at' => -1 ) )\r\n        ->limit( 10 )\r\n        ->get(); \r\n```\r\n\r\n<a name=\"save\"></a>\r\n### Save, Update and Delete\r\n`save` method is used to create and update objects. That's the code to create new object and write it to the database\r\n\r\n```php\r\n    // properties as array\r\n    $user = new User( array( 'name' => 'John', 'email' => 'email@email.com' ) );\r\n    \r\n    // or each property separately\r\n    $user = new User;\r\n    $user->name = 'John';\r\n    $user->emial = 'email@email.com';\r\n    \r\n    $user->save();\r\n```\r\nYou can get `_id` of newly created object just after `save`.\r\n\r\nDeleting is simple\r\n\r\n```php\r\n    $user->remove();\r\n```\r\n\r\nThose methods return the same results as the native `remove` and `save` methods. If you want to update multiple documents use the native function like [here](#multiple-update).\r\n\r\n### Extending Mapper\r\nYou can extend `Mapper` if you want to add more methods. For example I created UserMapper with has a method that posts a message on an user's Facebook wall. Just let it know which model class to use.\r\n\r\n```php\r\nclass UserMapper extends Mawelous\\Yamop\\Mapper\r\n{   \r\n    protected $_modelClassName = 'User';    \r\n    \r\n    public function findActiveUsers( $limit = 10, $sort = 'birthdate' )\r\n    {\r\n        //method code\r\n    }    \r\n}    \r\n```\r\n\r\nIf you want to register a different `Mapper` for a model just declare it in the model\r\n\r\n```php\r\nclass User extends Model\r\n{\r\n    ...\r\n    protected static $_mapperClassName = 'UserMapper';\r\n    ...\r\n```\r\n\r\nNow you just execute the `Mapper`\r\n\r\n```php\r\n    $mapper = User::getMapper();\r\n```\r\n\r\nThis will return an instance of UserMapper. You can also just create a new mapper\r\n\r\n```php\r\n    $userMapper = new UserMapper; \r\n```\r\n\r\n<a name=\"multiple-update\"></a>\r\n### Count, Indexes, and multi update\r\n\r\nAll methods called on `Mapper` that are not present are passed to the original [`MongoCollection`](#http://php.net/manual/en/class.mongocollection.php). So you can use `update`, `count`, and `ensureIndex` directly with the native methods.\r\n\r\n```php\r\n    //count\r\n    Message::getMapper()->count( array( 'to_id' => $userId, 'to_status' => Message::STATUS_UNREAD ) );\r\n    //update\r\n    Contest::getMapper()->update(\r\n            array('status' => Contest::STATUS_READY_DRAFT,\r\n                  'start_date' => array ('$lte' => new MongoDate(strtotime('midnight')) )),\r\n            array('$set' => array( 'status' => Contest::STATUS_ACTIVE) ),\r\n            array('multiple' => true)\r\n        );\r\n```\r\n\r\n<a name=\"embedded\"></a>\r\n### Embedded objects\r\n\r\nDo you have more objects within the current object? Yamop will convert it automatically. Just let it know.\r\n\r\n```php\r\nclass User extends Model\r\n{\r\n    protected static $_collectionName = 'users';\r\n    protected static $_mapperClassName = 'UserMapper';  \r\n    // One Address object embedded in address property\r\n    protected static $_embeddedObject = array (\r\n            'address' => 'Address',\r\n    );\r\n    // Many Notification objects embedded in array that is kept ass notifications\r\n    protected static $_embeddedObjectList = array (\r\n        'notifications' => 'Notification',\r\n    );\r\n```\r\n\r\n<a name=\"related\"></a>\r\n### Related objects\r\n\r\nIf there are relations between objects (there are sometimes) and you would like to \"join\" them, it's simpler than you would expect, even with `MongoDB`.\r\n\r\nYou don't have to register it anywhere. In my opinion it's better to do this explicit and avoid queries in background. \r\n\r\nHere's the magic:\r\n\r\n#### One\r\n\r\nThe `joinOne` method in every `Model` takes three parameters. First is the name of the property which keeps the `MongoId` of the related object, second is the related objects class, and third is the property name it will be joined at.\r\n\r\n```php\r\n    $user = User::findById( new MongoId( $stringId ) )->joinOne( 'contest_id', 'Contest', 'contest')\r\n    // and there it is\r\n    $contest = $user->contest;\r\n```\r\n\r\n#### Many\r\n\r\nThe `joinMany` method in every `Model` has also three parameters. First is the name of the property which keeps an array of `MongoId`'s, second is the related objects class, and third is the property name it will be joined at.\r\n\r\n```php\r\n    $user = User::findById( new MongoId( $stringId ) )->joinMany( 'contests', 'Contest', 'contests')\r\n    // and you have array of contests there\r\n    $contests = $user->contests;\r\n```\r\n\r\nIf you want to join items to a list of items use `join` in a `Mapper`. Three parameters as in `joinOne`.\r\n\r\n```php\r\n    $commentsList = Comment::getMapper()\r\n        ->find( array( 'contest_id' => new MongoId( $contestId ) ) )\r\n        ->join( 'user_id', 'User', 'author' )\r\n        ->limit( 10 )\r\n        ->get();\r\n```\r\n\r\n<a name=\"output\"></a>\r\n### Output format\r\n\r\nDefault fetching mode converts arrays to objects but you can also get array or JSON with `getArray` and `getJson`.\r\n\r\n```php\r\n    //first possibility\r\n    Comment::getMapper()\r\n        ->find( array( 'contest_id' => new MongoId( $contestId ) ) )\r\n        ->getArray();\r\n        \r\n    Comment::getMapper()\r\n        ->find( array( 'contest_id' => new MongoId( $contestId ) ) )\r\n        ->getJson();\r\n    \r\n    /* second possibility\r\n        three fetch types as constants in Mapper\r\n        FETCH_OBJECT\r\n        FETCH_ARRAY \r\n        FETCH_JSON  \r\n    */\r\n    Comment::getMapper( \\Mawelous\\Yamop\\Mapper::FETCH_JSON )\r\n        ->find( array( 'contest_id' => new MongoId( $contestId ) ) )\r\n        ->get();\r\n        \r\n    /* third possibility */\r\n    Comment::getMapper()\r\n        ->setFetchType(\\Mawelous\\Yamop\\Mapper::FETCH_JSON )\r\n        ->find( array( 'contest_id' => new MongoId( $contestId ) ) )\r\n        ->get();        \r\n```\r\n\r\n<a name=\"pagination\"></a>\r\n### Pagination\r\n\r\nYamop supports pagination with a little help from you. It has a `getPaginator` method which takes two parameters. First is the current page number, second is the amount of items per page.\r\n\r\n```php\r\n    User::getMapper()\r\n        ->find( 'status' => array ( '$ne' => User::STATUS_DELETED )) )\r\n        ->sort( array( $field => $direction ) )\r\n        ->getPaginator( $page, $perPage );\r\n```\r\n\r\nYour framework probably has its own paginator. Before you use the `getPaginator` method you have to implement the `_createPaginator` method in a mapper that extends `Mawelous\\Yamop\\Mapper`.\r\n\r\n[Laravel 3](http://laravel.com) would be extended like this:\r\n\r\n```php\r\n<?php\r\n\r\nclass Mapper extends \\Mawelous\\Yamop\\Mapper\r\n{\r\n    protected function _createPaginator($results, $totalCount, $perPage)\r\n    {\r\n        return \\Paginator::make( $results, $totalCount, $perPage ); \r\n    }\r\n}\r\n```\r\n\r\n<a name=\"timestamps\"></a>\r\n### Timestamps\r\n\r\nIt's common to have a `created_at` and `updated_at` key in our objects. If you want to have them be set automatically for your `Model`, just declare it:\r\n\r\n```php\r\nclass User extends Model\r\n{\r\n    ...\r\n    public static $timestamps = true;   \r\n    ....\r\n```\r\n\r\n<a name=\"datetime\"></a>\r\n### Printing date and time\r\n\r\nWhether you have a timestamp or not, you might still like to print the date or time. It's recommend to keep dates as `MongoDate` this way you can echo it with `getTime` or `getDate` which takes two parameters. First is the `MongoDate` property name, second is a string that represents format passed to the PHP `date` function:\r\n\r\n```php\r\n    //date as string\r\n    $user->getDate( 'birthdate', 'Y/m/d' );\r\n    //time as string\r\n    $user->getTime( 'created_at', 'Y/m/d H:i');\r\n    //time as string using default format set in $dateFormat\r\n    $user->getTime( 'created_at' );    \r\n```\r\n\r\n`Mawelous\\Yamop\\Model` has its default date format defined in the public static `$dateFormat` property and a time format in `$timeFormat`. You can override it if you like.\r\n\r\n<a name=\"transactions\"></a>\r\n### Transactions\r\n\r\n**EXPERIMENTAL!** - It's an addition to Yamop which works independently. It doesn't support a [two phase commit](#http://docs.mongodb.org/manual/tutorial/perform-two-phase-commits/) but at least it can revert changes.\r\n\r\nThat's what `Mawelous\\Yamop\\Transaction` is for. First you have to handle errors and run the `rollback` method within it. \r\n\r\nSimilar to this:\r\n\r\n```php\r\n    set_error_handler( function($code, $error, $file, $line) {\r\n        Transaction::rollback();\r\n        require_once path('sys').'error'.EXT;\r\n        Laravel\\Error::native($code, $error, $file, $line);\r\n    });\r\n```\r\n\r\nThen you can start using the `add` method. With `add` you add code to revert changes you made with save or update. You can use a closure to do that. \r\n\r\nHere an example:\r\n\r\n```php\r\n    User::getMapper()->update(\r\n        array('_id' => array ( '$in' => $userIds )),\r\n        array('$inc' => array ('active_contests' => -1 )),\r\n        array('multiple' => true)\r\n    );\r\n    \r\n    Transaction::add( function () use ( $userIds ) {\r\n        User::getMapper()->update(\r\n            array('_id' => array ( '$in' => $userIds )),\r\n            array('$inc' => array ('active_contests' => 1 )),\r\n            array('multiple' => true)\r\n            );\r\n    });\r\n```\r\nNow when error happens `rollback` will invoke all added methods.\r\n\r\n<a name=\"issues\"></a>\r\n## Issues\r\n\r\nAny issues or questions please [report here](https://github.com/Mawelous/yamop/issues)\r\n\r\n<a name=\"license\"></a>\r\n## License\r\n\r\nYamop is free software distributed under the terms of the [MIT license](http://opensource.org/licenses/MIT)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}